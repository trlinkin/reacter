---
title:  Overview
layout: default
---
<div class="row">
  <div class="span6">
    <div class="readable">
      <h2>What is Reacter?</h2>
      <p>
        Reacter is a utility written in Ruby designed to consume monitoring data from one or more sources, apply a series of processing rules to that data, then forward the output to one or more destinations.
      </p>

      <h4>Rationale</h4>
      <p>
        Monitoring things is complex and time-consuming.  There have been many approaches to making monitoring easier to approach over the years, and many of them have gained various degrees of adoption.  Many monitoring systems bill themselves as "the" monolithic all-in-one solution, whereas others commit to knowing their domain and performing well within it.  However, for most non-trivial architectures, a combination of monitoring components is brought together to form the complete package.
      </p>

      <p>
        Modern IT operations teams are increasingly tried and tested not by how many servers they manage, but by how much data they can effectively (and quickly) process, filter, collate, and ultimately act on.  As systems start to number in the thousands and tens of thousands, this task goes from being difficult to downright impossible without good tooling.  Many great tools exist to make discovery and analysis easier, but they all have one thing in common: they need data to work well.  Unfortunately, there is no one accepted, de facto standard for how to format and transmit that data.  What we end up with is a mix of different systems.  Some of them are super effective at data collection, where others are fantastic at organizing and presenting raw data and turning into usable information.  But what about where those systems must inevitably meet?  More often than not the edges of non-cooperating monitoring software come together with duct tape and glue; be it a shell script, a clever Perl daemon, or some other re-purposed mechanism for getting one program to talk to another.
        <br />
        <br />
        Reacter offers another option.
      </p>


      <h4>Architecture</h4>
      <p>
        Reacter operates on semi-structured data that originates from one or more sources.  Much like a database <a target="_blank" href="http://en.wikipedia.org/wiki/Extract,_transform,_load">ETL</a> tool, it works on the data it receives in stages.
      </p>

      <p>
        Data is first read or otherwise pushed into Reacter using <i>adapters</i>.  Adapters are the point where data enters the program.  Adapters can listen on a network socket, start an HTTP server, bind to a message queue, or read from a file.  Once this data is in Reacter it is normalized using <i>parsers</i>.  Parsers convert data from its native format into a uniform structure that can be processed within Reacter (a <i>message</i>).
      </p>

      <p>
        Messages are then processed through a highly-configurable series of <i>agents</i>.  Each agent is able to perform a certain set of tasks on a message.  Some agents merely receive the message and forward it somewhere else (the <code>relay</code> agent).  Some apply a set of rules for manipulating the message (the <code>mangle</code> agent).  And some use a more complex configuration to perform actions based on the content of the message (the <code>decider</code> agent).  These agents are all chained together to allow complex logic to be composed of simple, reusable components.
      </p>
    </div>

    <div class="readable">

    </div>
  </div>

  <div class="span5 pipeline">
    <h2>Data Processing Pipeline</h2>
    <p>

    </p>
    <p class="diagram">
      <img src="images/reacter-pipeline.png" />
    </p>
  </div>
</div>